Перед выполнением задания, я ознакомилась с документацией и статьями о работе ServiceWorker, в которых был описан правильных порядок его настройки и подключения. При проверке всех этапов подключения ServiceWorker-а были выявлены участки кода, в которых были допущены ошибки. Таким образом, были исправлены ошибки 2 и 3.
Синтаксические ошибки были выявлены при попытке запуска приложения, они были выведены в консоль.
Далее при работе приложения были замечены запросы localHost:undefined, после чего в коде при помощи команды console.log() было найдено место возникновения undefined.
Пятая ошибка была найдена при разборе кода метода, в частности команды Promice.Race. Логикой приложения не предполагается, что команды получения данных с сервера и из кэша, выполняются параллельно и независимо друг от друга.


ИСПРАВЛЕННЫЕ ОШИБКИ

1. Исправлена синтаксическая ошибка лишней ';'
	return event.respondWith(
        	getFromCache(event.request).catch(fetchAndPutToCache)
    	);

2. Исправлены пути к файлам для кэширования
	'css/index.css',
	'js/index.js'

3. Файл worker.js перенесен в корень для корректного определения scope, страницы не будут подконтрольны ServiceWorker-у, если они находятся в директории выше.

4. Исправлена обработка catch при запросе данных из кэша, в случае их отсутствия в кэше, получаем их, затем кэшируем. В изначальной реализации не передавался объект запроса для получения, он был undefined.
	getFromCache(event.request).catch(function() {             
            fetchAndPutToCache(event.request); 
        })

5. Исправлена загрузка данных о студентах, сначала происходит запрос к серверу на получение данных, если сервер не доступен, получаем данные из кэша. В изначальной реализации использовался метод Promide.Race, который одновременно запускал получение данных из кэша и с сервера, и возвращал результат первого завершенного. В связи с этим, при добавлении студента, обновленный список мог быть получен из кэша, а не с сервера, если этот Promise первым возвращал результат.
	if (/^\/api\/v1/.test(requestURL.pathname)) {                	
        	return event.respondWith(
            	fetchAndPutToCache(event.request).catch(function() {
                	getFromCache(event.request);
            })              
        );
    }
6. По условиям данного задания сайт разворачивается на localhost, при этом данный код будет работать правильно.Однако, возможна потенциальная ошибка, в случае если сайт развернут на удаленном сервере. В этом случае соединение необходимо устанавливать по протоколу HTTPS для работы ServiceWorker-а. В данном же случае оно не требуется, поскольку localhost отвечает требованиям защищенности.

Так же  при первом открытии приложения в браузере происходит регистрация объекта ServiceWorker-а в браузере, однако, для открытой страницы он остается недоступен до ее перезагрузки. При повторном же открытии страницы (в новой вкладке), ServiceWorker доступен сразу и в этот момент он уже запущен.


РЕАЛИЗАЦИЯ РАБОТЫ В ОФФЛАЙН

1. При добавлении студента, происходит перехват Post  запроса к серверу worker.js.
2. Проверяется, в каком режиме находится сервер - онлайн или оффлайн.
3. Если сервер онлайн, запрос направляется на сервер, алгоритм завершается. Иначе читаем из кэша ответ на Get запрос получения студентов, из которого извлекаем список студентов.
5. Из POST запроса добавления/обновления извлекаем данные о студенте.
6. Модифицируем существующего студента или добавляем нового студента к списку студентов, извлеченных из кэша в пункте 3.
7. Формируем ответ на Post запрос получения студентов с обновленным списком студентов.
8. Сохраняем  ответ в кэш как Get запрос. 
9. Возвращаем ответ приложению.


СИНХРОНИЗАЦИЯ

1. При каждом запросе с сервера списка студентов происходит его перехват.
2. Если сервер онлайн, из кэша извлекаются добавленные или обновленные в оффлайне студенты. Добавленные студенты определяются отсутствием поля 'id' у студента, обновленные - присутствием поля 'modified' со значением true.
3. Добавленные и обновленные студенты посылаются на сервер с помощью запроса PUT.
4. После этого с сервера запрашивается список студентов, в котором уже будут содержаться обновленные данные о студенте


ОПРЕДЕЛЕНИЕ РЕЖИМА ОНЛАЙН/ОФФЛАЙН

Режим можно определить по флагу у объекта navigator.onLine. Минусы: не дает информацию о доступности сервера; в случае если сервер расположен на локальном компьютере, подключение по интернет не нужно вовсе. 
Определение режима реализовано путем попытки получения запроса с сервера. В качестве адреса используется корень веб-приложения '/'. В случае успешного получения ответа с сервера, функция определения режима возвращает true, в противном случае false. Плюсом такой реализации является возможность перед выполнением запроса проверить доступность сервера, после чего выполнить необходимую логику. Минусом является дополнительное ожидание ответа от сервера, но его можно уменьшить, если запрашивать специальную ссылку, возвращающую ответ минимальной длины. Так же существует потенциальная возможность отключения сервера между моментом проверки его доступности и выполнением запроса к нему. Решением в этой ситуации является обработка ошибок выполнения запроса и перенаправление их на логику работы с кэшем.